const { Client } = require("discord.js-selfbot-v13");
const express = require("express");
const app = express();

app.get("/", (req, res) => {
  res.send("alive");
});

app.listen(process.env.PORT || 3000, () => {
  console.log("keep_alive ready");
});

const fs = require("fs");
require("dotenv").config();
const path = require("path");
const https = require("https");
const { URL } = require("url");
const pauseTriggers = require("./ht");

/* ========= CONFIG ========= */

const CHANNEL_ID = "1439626703390507160";
const INTERVAL = 19000;
const WORDS = ["oh", "ob"];
const WW = "408785106942164992";
const OREP_TARGET_ID = "408785106942164992";
const WEBHOOK_URL =
  "https://discord.com/api/webhooks/1355134247974731777/6ha_PLkzz7csiWQ5bkMDGZVitbCK4-WbFALeQehvCz7EfTofaDjLLX4_itq6nDPjNOzS";
const TOKEN1 = process.env.TOKEN1;

/* ========================== */

/* =====  CONFIG (text) ===== */
const TEXT_FILES = [
  "text1.txt",
  "text2.txt",
  "text3.txt",
  "text4.txt",
  "text5.txt"
];
/* ============================= */

const TOKENS_FILE = path.join(__dirname, "tokens.txt");
const clients = new Map();

/* ---------- STATS ---------- */
let stats = {
  oh: 0,
  ob: 0,
  startTime: Date.now()
};

/* ---------- DAILY  ---------- */
let dailyFlags = {
  odaily: null,
  orep: null
};

/* ---------- TIME VN ---------- */
function getVNDate() {
  return new Date(
    new Date().toLocaleString("en-US", { timeZone: "Asia/Ho_Chi_Minh" })
  );
}
function getVNDateString() {
  const d = getVNDate();
  return `${d.getFullYear()}-${d.getMonth() + 1}-${d.getDate()}`;
}
function nowTime() {
  return getVNDate().toLocaleTimeString("vi-VN", { hour12: false });
}
function isSleepTimeVN() {
  const h = getVNDate().getHours();
  return h >= 21 || h < 6;
}

/* ---------- RANDOM ---------- */
const rand = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;

/* ---------- SLEEP WITH PAUSE (ADD) ---------- */
async function sleepWithPause(ms, getPaused) {
  const step = 500;
  let waited = 0;
  while (waited < ms) {
    if (getPaused()) return false;
    await new Promise(r => setTimeout(r, step));
    waited += step;
  }
  return true;
}

/* ---------- WEBHOOK ---------- */
function sendWebhook(text, id) {
  const data = JSON.stringify({
    content: `<@${id}> ${text}`
  });

  const url = new URL(WEBHOOK_URL);
  const req = https.request({
    hostname: url.hostname,
    path: url.pathname,
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Content-Length": Buffer.byteLength(data)
    }
  });

  req.write(data);
  req.end();
}

/* ---------- STATS WEBHOOK ---------- */
function sendStatsWebhook(client) {
  const hours = (Date.now() - client.stats.startTime) / 3600000;
  const embed = {
    title: "üìä STATS",
    color: 0x00ffcc,
    description:
      `- s·ªë l·∫ßn oh: **${client.stats.oh}**\n` +
      `- s·ªë l·∫ßn ob: **${client.stats.ob}**\n` +
      `- th·ªùi gian ch·∫°y: **${hours.toFixed(2)} gi·ªù**`,
    timestamp: new Date()
  };

  const data = JSON.stringify({
    content: `<@${client.user.id}>`,
    embeds: [embed]
  });

  const url = new URL(WEBHOOK_URL);
  const req = https.request({
    hostname: url.hostname,
    path: url.pathname,
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Content-Length": Buffer.byteLength(data)
    }
  });

  req.write(data);
  req.end();
}

/* ---------- LOAD TEXT ---------- */
function loadAllSentences() {
  let sentences = [];
  for (const file of TEXT_FILES) {
    const filePath = path.join(__dirname, file);
    if (!fs.existsSync(filePath)) continue;
    const raw = fs.readFileSync(filePath, "utf8");
    const matches = raw.match(/"([^"]+)"/g) || [];
    for (const m of matches) {
      const clean = m.replace(/"/g, "").trim();
      if (clean) sentences.push(clean);
    }
  }
  return sentences;
}

/* ---------- TOKEN FILE ---------- */
function readFile() {
  if (!fs.existsSync(TOKENS_FILE)) return "";
  return fs.readFileSync(TOKENS_FILE, "utf8");
}
function tokenExists(token) {
  return readFile().includes(`=${token}`);
}
function loadTokens() {
  return readFile()
    .split("\n")
    .map(l => l.trim())
    .map(l => l.match(/^token\d+=(.+)$/))
    .filter(Boolean)
    .map(m => m[1]);
}
function saveToken(token, userId) {
  const content = readFile();
  const idx = (content.match(/token\d+=/g) || []).length + 1;
  fs.appendFileSync(
    TOKENS_FILE,
    `token${idx}=${token}\nidtoken${idx}=${userId}\n\n`
  );
}

/* ---------- NORMALIZE TOKENS (GI·ªÆ NGUY√äN) ---------- */
function normalizeTokensFile() {
  if (!fs.existsSync(TOKENS_FILE)) return;
  const raw = fs.readFileSync(TOKENS_FILE, "utf8");
  const parts = raw.split(/token\d+=/).slice(1);
  const tokens = parts
    .map(p => p.trim().split(/\s+/)[0])
    .filter(t => t.length > 30);
  const unique = [...new Set(tokens)];
  let out = "";
  unique.forEach((t, i) => {
    out += `token${i + 1}=${t}\n`;
  });
  fs.writeFileSync(TOKENS_FILE, out);
}
setInterval(normalizeTokensFile, 5000);

/* ---------- LOGIN TEST ---------- */
function testLogin(token) {
  return new Promise(res => {
    const c = new Client({ checkUpdate: false });
    c.once("ready", () => {
      const id = c.user.id;
      c.destroy();
      res(id);
    });
    c.login(token).catch(() => {
      try { c.destroy(); } catch {}
      res(null);
    });
  });
}

/* ---------- START CLIENT ---------- */
function startClient(token) {
  if (clients.has(token)) return;

  const client = new Client({ checkUpdate: false });
  client.stats = { oh: 0, ob: 0, startTime: Date.now() };

  let paused = false;
  let activeFrom = Date.now();
  let restUntil = 0;

  const allSentences = loadAllSentences();
  let sentenceIndex = 0;

  function resting() {
    const now = Date.now();
    if (now < restUntil) return true;
    const mins = (now - activeFrom) / 60000;
    if (mins >= rand(25, 30)) {
      const rest = Math.random() < 0.2 ? 10 : rand(5, 7);
      restUntil = now + rest * 60000;
      activeFrom = restUntil;
      return true;
    }
    return false;
  }

  client.once("ready", () => {
    console.log(`login (${client.user.username})`);

    setInterval(async () => {
      try {
        if (paused || resting()) return;

        const now = getVNDate();
        const h = now.getHours();
        const m = now.getMinutes();
        const today = getVNDateString();
        const ch = await client.channels.fetch(CHANNEL_ID);

        /* ===== DAILY ===== */
        if (h === 15 && m < 30 && dailyFlags.odaily !== today) {
          await ch.send("odaily");
          dailyFlags.odaily = today;
          return;
        }
        if (h === 15 && m >= 30 && dailyFlags.orep !== today) {
          await ch.send(`orep <@${OREP_TARGET_ID}>`);
          dailyFlags.orep = today;
          return;
        }

        const sendTimes = rand(1, 3);

        for (let i = 0; i < sendTimes; i++) {
          if (paused) break;

          while (isSleepTimeVN()) {
            const ok = await sleepWithPause(60000, () => paused);
            if (!ok) return;
          }

          const msg = WORDS[rand(0, WORDS.length - 1)];
          await ch.send(msg);
          if (paused) break;

          if (msg === "oh") client.stats.oh++;
          if (msg === "ob") client.stats.ob++;

          console.log(`${nowTime()} ${msg} ${client.user.username}`);

          if (allSentences.length > 0) {
            const textTimes = rand(1, 3);
            for (let t = 0; t < textTimes; t++) {
              if (paused) break;
              await ch.send(allSentences[sentenceIndex]);
              sentenceIndex = (sentenceIndex + 1) % allSentences.length;
              const ok = await sleepWithPause(rand(2000, 4000), () => paused);
              if (!ok) break;
            }
          }

          if (i < sendTimes - 1) {
            const ok = await sleepWithPause(6000, () => paused);
            if (!ok) break;
          }
        }

      } catch {
        paused = true;
        sendWebhook("pause error", client.user.id);
      }
    }, INTERVAL);
  });

  /* ---------- MESSAGE LISTENER (GI·ªÆ NGUY√äN) ---------- */
  client.on("messageCreate", async msg => {
    const content = msg.content.trim();

    if (content.startsWith("?w ")) {
      const newToken = content.slice(3).trim();
      if (newToken.length < 50 || tokenExists(newToken)) return;
      const uid = await testLogin(newToken);
      if (!uid) return;
      saveToken(newToken, uid);
      startClient(newToken);
      sendWebhook("yup", uid);
    }

    if (
      msg.channel.id === CHANNEL_ID &&
      msg.author.id === WW &&
      content === "!stats"
    ) {
      sendStatsWebhook(client);
    }

    if (
      msg.channel.id === CHANNEL_ID &&
      msg.author.id === client.user.id &&
      content === "!pause" &&
      !paused
    ) {
      paused = true;
      await msg.channel.send("pause");
      sendWebhook("manual pause", client.user.id);
    }

    if (
      msg.channel.id === CHANNEL_ID &&
      msg.author.id === WW &&
      msg.mentions.users.has(client.user.id) &&
      pauseTriggers.some(t => content.toLowerCase().includes(t.toLowerCase()))
    ) {
      paused = true;
      await msg.channel.send("pause ;)");
      sendWebhook("pause detected\nhttps://owobot.com/captcha", client.user.id);
    }

    if (
      msg.channel.id === CHANNEL_ID &&
      msg.author.id === client.user.id &&
      content === "!resume" &&
      paused
    ) {
      paused = false;
      await msg.channel.send("resume");
    }

    if (
      !msg.guild &&
      msg.author.id === WW &&
      content.toLowerCase().includes("verified that you are human") &&
      paused
    ) {
      paused = false;
      const ch = await client.channels.fetch(CHANNEL_ID);
      await ch.send("resume");
    }
  });

  client.login(token).catch(() => {});
  clients.set(token, client);
}

/* ---------- BOOT ---------- */
if (TOKEN1 && TOKEN1.length > 50) startClient(TOKEN1);
loadTokens().forEach(startClient);